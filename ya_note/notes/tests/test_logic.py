from notes.models import Note
from http import HTTPStatus
from .base_test import BaseTestCase, UPDATE_NOTE_DATA, NOTE_DATA, URLS_INSTANCE


class TestLogic(BaseTestCase):
    """Тесты логики приложения."""
    def test_logged_in_user_can_create_note(self):
        """Пользователь может создать заметку."""
        self.client.force_login(self.user)
        initial_notes = set(Note.objects.all())

        self.client.post(URLS_INSTANCE.add_note, data=UPDATE_NOTE_DATA)

        new_notes = set(Note.objects.all()) - initial_notes
        self.assertEqual(len(new_notes), 1)

        new_note = new_notes.pop()
        self.assertEqual(new_note.title, UPDATE_NOTE_DATA['title'])
        self.assertEqual(new_note.text, UPDATE_NOTE_DATA['text'])
        self.assertEqual(new_note.slug, UPDATE_NOTE_DATA['slug'])
        self.assertEqual(new_note.author, self.user)

    def test_create_note_redirects_to_success_page(self):
        """
        Пользователь перенаправляется
        на страницу успешного создания заметки
        """
        self.client.force_login(self.user)
        response = self.client.post(
            URLS_INSTANCE.add_note,
            data=UPDATE_NOTE_DATA,
            follow=True
        )
        self.assertRedirects(response, URLS_INSTANCE.success)

    def test_anonymous_cannot_create_note(self):
        """Анонимный пользователь не может создать заметку."""
        self.client.logout()
        Note.objects.all().delete()

        initial_count_before = Note.objects.count()
        self.assertEqual(initial_count_before, 0)

        response = self.client.post(
            URLS_INSTANCE.add_note,
            data=UPDATE_NOTE_DATA,
            follow=True
        )

        self.assertEqual(Note.objects.count(), initial_count_before)
        self.assertRedirects(
            response,
            f'{URLS_INSTANCE.login}?next={URLS_INSTANCE.add_note}'
        )

    def test_slug_is_unique(self):
        """Slug заметки должен быть уникальным."""
        initial_count = Note.objects.count()
        self.client.post(URLS_INSTANCE.add_note, data=NOTE_DATA)
        response = self.client.post(
            URLS_INSTANCE.add_note,
            data=NOTE_DATA,
            follow=True
        )
        self.assertFormError(
            response, 'form', 'slug',
            'sample_slug - такой slug уже существует, '
            'придумайте уникальное значение!'
        )

        self.assertEqual(Note.objects.count(), initial_count)

    def test_slug_autogenerated(self):
        """Slug заметки генерируется автоматически."""
        form_data = {
            'title': 'Sample title',
            'text': 'Sample text',
            'slug': 'tekstovaya-zametka',
        }
        self.user_client.post(
            URLS_INSTANCE.add_note,
            data=form_data,
            follow=True
        )
        note = Note.objects.get(title=form_data['title'])
        expected_slug = 'tekstovaya-zametka'

        self.assertEqual(note.slug, expected_slug)

    def test_user_cannot_edit_someone_elses_note(self):
        """Пользователь не может редактировать чужую заметку."""
        self.client.force_login(self.reader)

        old_title = self.note.title
        old_text = self.note.text
        old_slug = self.note.slug
        old_author = self.note.author

        initital_note_count = Note.objects.count()

        response = self.client.post(
            URLS_INSTANCE.edit_note,
            data=UPDATE_NOTE_DATA,
            follow=True
        )

        self.note = Note.objects.get(id=self.note.id)

        self.assertEqual(self.note.title, old_title)
        self.assertEqual(self.note.text, old_text)
        self.assertEqual(self.note.slug, old_slug)
        self.assertEqual(self.note.author, old_author)

        self.assertEqual(Note.objects.count(), initital_note_count)
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND)

    def test_anonymous_cannot_edit_note(self):
        """Анонимный пользователь не может редактировать заметку."""
        self.client.logout()
        initial_note_count = Note.objects.count()
        response = self.client.post(
            URLS_INSTANCE.edit_note,
            data=UPDATE_NOTE_DATA,
            follow=True
        )
        self.note.refresh_from_db
        self.assertEqual(self.note.title, NOTE_DATA['title'])
        self.assertEqual(self.note.text, NOTE_DATA['text'])
        self.assertEqual(self.note.slug, NOTE_DATA['slug'])
        self.assertEqual(self.note.author, self.user)

        self.assertEqual(Note.objects.count(), initial_note_count)

        login_url = URLS_INSTANCE.login
        self.assertRedirects(
            response, f'{login_url}?next={URLS_INSTANCE.edit_note}'
        )

    def test_user_can_delete_own_note(self):
        """Пользователь может удалить свою заметку."""
        initital_note_count = Note.objects.count()

        note_id = self.note.id
        response = self.client.post(URLS_INSTANCE.delete_note, follow=True)

        self.assertEqual(Note.objects.count(), initital_note_count - 1)
        self.assertFalse(Note.objects.filter(id=note_id).exists())

        self.assertRedirects(response, URLS_INSTANCE.success)

    def test_user_cannot_delete_others_note(self):
        """Пользователь не может удалить чужую заметку."""
        initial_note_count = Note.objects.count()

        note_data = self.note
        self.client.logout()
        self.client.force_login(self.reader)

        response = self.client.post(URLS_INSTANCE.delete_note, follow=True)

        self.assertEqual(Note.objects.count(), initial_note_count)
        self.assertEqual(response.status_code, HTTPStatus.NOT_FOUND)
        note_data.refresh_from_db()

        self.assertEqual(note_data.title, self.note.title)
        self.assertEqual(note_data.text, self.note.text)
        self.assertEqual(note_data.slug, self.note.slug)
        self.assertEqual(note_data.author, self.note.author)
